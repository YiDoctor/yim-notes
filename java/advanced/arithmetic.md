# 算法

## 主要内容

- 复杂度分析
- 数据结构
- 算法

## 一 数据结构

### 1.1 时间复杂度分析

#### 1.1.1 分析方法

**1. 只关注循环执行次数最多的一段代码**

**2. 加法法则：总复杂度等于量级最大的那段代码的复杂度**

**3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**

#### 1.1.2 时间复杂度度的表示方法

![表示方法](../images/复杂度量级.jpg)

### 1.2 数组

**数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。**

#### 1.2.1 线性表

**线性表**（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。

![线性](../images/线性表.jpg)

而与它相对立的概念是**非线性表**，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

![](../images/非线性.jpg)

#### 1.2.2 数组的优缺点

数组是：**连续的内存空间和相同类型的数据**。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。

如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。 

#### 1.2.3 对比容器（ArraryList）和数组

如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。

不过，这里需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好**在创建 ArrayList 的时候事先指定数据大小**。

1. Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。

2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。

3. 当要表示多维数组时，用数组往往会更加直观。

   ```java
   // 容器创建多维数组
   ArrayList<ArrayList> arrayLists = new ArrayList<>();
   // 二维数组
   int[][] ints = new int[6][8];
   ```

**总结内容：**

数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。ArraryList

### 1.3 链表

