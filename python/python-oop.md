# python面向对象

> **面向对象编程** —— `Object Oriented Programming` 简写 `OOP`

## 目标

* python中类和对象
* 属性和方法
* 面向对象的三大特征

## 一 类和对象

**dir内置函数**

| 序号 | 方法名     | 类型 | 作用                                         |
| ---- | ---------- | ---- | -------------------------------------------- |
| 01   | `__new__`  | 方法 | **创建对象**时，会被 **自动** 调用           |
| 02   | `__init__` | 方法 | **对象被初始化**时，会被 **自动** 调用       |
| 03   | `__del__`  | 方法 | **对象被从内存中销毁**前，会被 **自动** 调用 |
| 04   | `__str__`  | 方法 | 返回**对象的描述信息**，`print` 函数输出使用 |

### 1.1 类的定义

- 在 `Python` 中要定义一个只包含方法的类，语法格式如下：定义一个Game类

  ```python
  class Game(object):
  
      # 游戏最高分，类属性
      top_score = 0
  
      @staticmethod
      def show_help():
          print("帮助信息：让僵尸走进房间")
          
      @classmethod
      def show_top_score(cls):
          print("游戏最高分是 %d" % cls.top_score)
  
      def __init__(self, player_name):
          self.player_name = player_name
  
      # 实例方法
      def start_game(self):
          print("[%s] 开始游戏..." % self.player_name)
          
          # 使用类名.修改历史最高分
          Game.top_score = 999
  
  # 1. 查看游戏帮助
  Game.show_help()
  
  # 2. 查看游戏最高分
  Game.show_top_score()
  
  # 3. 创建游戏对象，开始游戏
  game = Game("小明")
  
  game.start_game()
  
  # 4. 游戏结束，查看游戏最高分
  Game.show_top_score()
  ```

- **方法** 的定义格式和之前学习过的**函数** 几乎一样

- 区别在于第一个参数必须是 `self`

#### 1.1.1 方法中的 `self` 参数

由 **哪一个对象** 调用的方法，方法内的 `self` 就是 **哪一个对象的引用**

- 在类封装的方法内部，`self` 就表示 **当前调用方法的对象自己**
- **调用方法时**，程序员不需要传递 `self` 参数
- 在方法内部
  - 可以通过 `self.` **访问对象的属性**
  - 也可以通过 `self.` **调用其他的对象方法**
- 在 **类的外部**，通过 `变量名.` 访问对象的 **属性和方法**
- 在 **类封装的方法中**，通过 `self.` 访问对象的 **属性和方法**

### 1.2 类的属性

**类属性** 就是针对 **类对象** 定义的属性

- 使用 **赋值语句** 在 `class` 关键字下方可以定义 **类属性**
- **类属性** 用于记录 **与这个类相关** 的特征

#### 1.2.1 类属性的定义

类属性定义在`__init__`中，用来描述事物的特征

```python
class Cat:

    def __init__(self, name):
        print("初始化方法 %s" % name)
        self.name = name
    ...
    
tom = Cat("Tom")
...

lazy_cat = Cat("大懒猫")
...
```

#### 1.2.2 类属性的访问

访问类属性：**类名.类属性**

### 1.3 类的方法和静态方法

#### 1.3.1 类的方法

- **类方法** 就是针对 **类对象** 定义的方法
  - 在 **类方法** 内部可以直接访问 **类属性** 或者调用其他的 **类方法**

**语法格式：**

```python
@classmethod
def 类方法名(cls):
    pass
```

- 类方法需要用 **修饰器** `@classmethod` 来标识，**告诉解释器这是一个类方法**
- 类方法的 **第一个参数** 应该是 `cls`
  - 由 **哪一个类** 调用的方法，方法内的 `cls` 就是 **哪一个类的引用**
  - 这个参数和 **实例方法** 的第一个参数是 `self` 类似
  - **提示** 使用其他名称也可以，不过习惯使用 `cls`
- 通过 **类名.** 调用 **类方法**，**调用方法时**，不需要传递 `cls` 参数
- **在方法内部**
  - 可以通过 `cls.` **访问类的属性**
  - 也可以通过 `cls.` **调用其他的类方法**

#### 1.3.2 静态方法

- 在开发时，如果需要在 **类** 中封装一个方法，这个方法：
  - 既 **不需要** 访问 **实例属性** 或者调用 **实例方法**
  - 也 **不需要** 访问 **类属性** 或者调用 **类方法**
- 这个时候，可以把这个方法封装成一个 **静态方法**

**语法如下**

```python
@staticmethod
def 静态方法名():
    pass
```

- **静态方法** 需要用 **修饰器** `@staticmethod` 来标识，**告诉解释器这是一个静态方法**
- 通过 **类名.** 调用 **静态方法**

### 1.4 创建对象

类是对一类事物的统一描述，可以创建多个实例对象，来描述具体的事物

```
对象变量 = 类名()
```

1. 创建出来的 **对象** 叫做 **类** 的 **实例**
2. 创建对象的 **动作** 叫做 **实例化**
3. **对象的属性** 叫做 **实例属性**
4. **对象调用的方法** 叫做 **实例方法**

**在程序执行时：**

1. 对象各自拥有自己的 **实例属性**
2. 调用对象方法，可以通过 `self.`
   - 访问自己的属性
   - 调用自己的方法

**创建对象过程**

1. 为对象在内存中 **分配空间** —— 创建对象
2. 为对象的属性 **设置初始值** —— 初始化方法(`init`)

### 1.5身份运算符（is is not）

身份运算符用于 **比较** 两个对象的 **内存地址** 是否一致 —— **是否是对同一个对象的引用**

- 在 `Python` 中针对 `None` 比较时，建议使用 `is` 判断

| 运算符 | 描述                                      | 实例                            |
| ------ | ----------------------------------------- | ------------------------------- |
| is     | is 是判断两个标识符是不是引用同一个对象   | x is y，类似 id(x) == id(y)     |
| is not | is not 是判断两个标识符是不是引用不同对象 | x is not y，类似 id(a) != id(b) |

**is 与 == 区别：**

`is` 用于判断 **两个变量 引用对象是否为同一个** 
`==` 用于判断 **引用变量的值** 是否相等

```python
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> b is a 
False
>>> b == a
True
```

## 二 面向对象三大特征

### 2.1 封装 

隐藏对象的实现细节，提供私有的属性和方法，对外提供统一的方式进行调用

####  2.1.1 代码示例

```python
class Person:
    """人类"""
	
    def __init__(self, name, weight):

        self.name = name
        self.weight = weight

    def __str__(self):

        return "我的名字叫 %s 体重 %.2f 公斤" % (self.name, self.weight)

    def run(self):
        """跑步"""

        print("%s 爱跑步，跑步锻炼身体" % self.name)
        self.weight -= 0.5

    def eat(self):
        """吃东西"""

        print("%s 是吃货，吃完这顿再减肥" % self.name)
        self.weight += 1


xiaoming = Person("小明", 75)

xiaoming.run()
xiaoming.eat()
xiaoming.eat()

print(xiaoming)
```

#### 2.1.2  私有属性和私有方法

- 在 **定义属性或方法时**，在 **属性名或者方法名前** 增加 **两个下划线**，定义的就是 **私有** 属性或方法

```python
class Women:

    def __init__(self, name):

        self.name = name
        # 不要问女生的年龄
        self.__age = 18

    def __secret(self):
        print("我的年龄是 %d" % self.__age)


xiaofang = Women("小芳")
# 私有属性，外部不能直接访问
# print(xiaofang.__age)

# 私有方法，外部不能直接调用
# xiaofang.__secret()
```

> 提示：在日常开发中，**不要使用这种方式**(.)**访问对象的 私有属性 或 私有方法** 

- `Python` 中，并没有 **真正意义** 的 **私有**

- 在给 **属性**、**方法** 命名时，实际是对 **名称** 做了一些特殊处理，使得外界无法访问到

- **处理方式**：在 **名称** 前面加上 `_类名` => `_类名__名称`

  ```python
  # 私有属性，外部不能直接访问到
  print(xiaofang._Women__age)
  
  # 私有方法，外部不能直接调用
  xiaofang._Women__secret()
  ```

### 2.2 继承

继承是实现代码重用的重要体现，python中支持`单继承`和`多继承`，支持多重继承

- **子类** 拥有 **父类** 的所有 **方法** 和 **属性**

#### 2.2.1 单继承

语法格式：

```python
class 类名(父类名):

    pass
```

#### 2.2.2 重写

**重写** 父类方法有两种情况：

1. **覆盖** 父类的方法
   1. 具体的实现方式，就相当于在 子类中 定义了一个 和父类同名的方法并且实现
   2. 重写之后，在运行时，**只会调用** 子类中重写的方法，而不再会调用 **父类封装的方法**
2. 对父类方法进行 **扩展**
   1. **在子类中** **重写** 父类的方法
   2. 在需要的位置使用 `super().父类方法` 来调用父类方法的执行
   3. 代码其他的位置针对子类的需求，编写 **子类特有的代码实现**

##### 关于 `super`

- 在 `Python` 中 `super` 是一个 **特殊的类**
- `super()` 就是使用 `super` 类创建出来的对象
- **最常** 使用的场景就是在 **重写父类方法时**，调用 **在父类中封装的方法实现**

#### 2.2.3 父类的 私有属性 和 私有方法

1. **子类对象** **不能** 在自己的方法内部，**直接** 访问 父类的 **私有属性** 或 **私有方法**
2. **子类对象** 可以通过 **父类** 的 **公有方法** **间接** 访问到 **私有属性** 或 **私有方法**

#### 2.2.4 多继承

语法格式：

```python
class 子类名(父类名1, 父类名2...)
    pass
```

多继承问题：如果 **不同的父类** 中存在 **同名的方法**，**子类对象** 在调用方法时，会调用 **哪一个父类中**的方法呢？

> 提示：**开发时，应该尽量避免这种容易产生混淆的情况！** —— 如果 **父类之间** 存在 **同名的属性或者方法**，应该 **尽量避免** 使用多继承

Python 中的 MRO —— 方法搜索顺序（知道）

- `Python` 中针对 **类** 提供了一个 **内置属性** `__mro__` 可以查看 **方法** 搜索顺序
- MRO 是 `method resolution order`，主要用于 **在多继承时判断 方法、属性 的调用 路径**

#### 2.2.5 新式类与旧式（经典）类

> `object` 是 `Python` 为所有对象提供的 **基类**，提供有一些内置的属性和方法，可以使用 `dir` 函数查看

- **新式类**：以 `object` 为基类的类，**推荐使用**
- **经典类**：不以 `object` 为基类的类，**不推荐使用**
- 在 `Python 3.x` 中定义类时，如果没有指定父类，会 **默认使用** `object` 作为该类的 **基类** —— `Python 3.x` 中定义的类都是 **新式类**
- 在 `Python 2.x` 中定义类时，如果没有指定父类，则不会以 `object` 作为 **基类**

> **新式类** 和 **经典类** 在多继承时 —— **会影响到方法的搜索顺序**

为了保证编写的代码能够同时在 `Python 2.x` 和 `Python 3.x` 运行！
今后在定义类时，**如果没有父类，建议统一继承自 object**

```python
class 类名(object):
    pass
```

### 2.3 多态

**多态** 不同的 **子类对象** 调用相同的 **父类方法**，产生不同的执行结果

- **多态** 可以 **增加代码的灵活度**
- 以 **继承** 和 **重写父类方法** 为前提
- 是调用方法的技巧，**不会影响到类的内部设计**

```python
class Dog(object):

    def __init__(self, name):
        self.name = name

    def game(self):
        print("%s 蹦蹦跳跳的玩耍..." % self.name)


class XiaoTianDog(Dog):

    def game(self):
        print("%s 飞到天上去玩耍..." % self.name)


class Person(object):

    def __init__(self, name):
        self.name = name

    def game_with_dog(self, dog):

        print("%s 和 %s 快乐的玩耍..." % (self.name, dog.name))

        # 让狗玩耍
        dog.game()


# 1. 创建一个狗对象
# wangcai = Dog("旺财")
wangcai = XiaoTianDog("飞天旺财")

# 2. 创建一个小明对象
xiaoming = Person("小明")

# 3. 让小明调用和狗玩的方法
xiaoming.game_with_dog(wangcai)
```

## 三 异常

### 3.1 异常的概念

- 程序在运行时，如果 `Python 解释器` **遇到** 到一个错误，**会停止程序的执行，并且提示一些错误信息**，这就是 **异常**
- **程序停止执行并且提示错误信息** 这个动作，我们通常称之为：**抛出(raise)异常**

### 3.2 捕获异常

在程序开发中，如果 **对某些代码的执行不能确定是否正确**，可以增加 `try(尝试)` 来 **捕获异常**

捕获异常语法格式：

```python
try:
    # 尝试执行的代码
    pass
except 错误类型1:
    # 针对错误类型1，对应的代码处理
    pass
except 错误类型2:
    # 针对错误类型2，对应的代码处理
    pass
except (错误类型3, 错误类型4):
    # 针对错误类型3 和 4，对应的代码处理
    pass
except Exception as result:
    # 打印错误信息
    print(result)
else:
    # 没有异常才会执行的代码
    pass
finally:
    # 无论是否有异常，都会执行的代码
    print("无论是否有异常，都会执行的代码")
```

### 3.3 异常的传递

- **异常的传递** —— 当 **函数/方法** 执行 **出现异常**，会 **将异常传递** 给 函数/方法 的 **调用一方**
- 如果 **传递到主程序**，仍然 **没有异常处理**，程序才会被终止

> 提示
>
> - 在开发中，可以在主函数中增加 **异常捕获**
> - 而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的 **异常捕获** 中
> - 这样就不需要在代码中，增加大量的 **异常捕获**，能够保证代码的整洁

### 3.4 抛出 `raise` 异常

- 在开发中，除了 **代码执行出错** `Python` 解释器会 **抛出** 异常之外
- 还可以根据 **应用程序** **特有的业务需求** **主动抛出异常**
- `Python` 中提供了一个 `Exception` **异常类**
- 在开发时，如果满足 特定业务需求时，希望 抛出异常，可以：
  1. 创建 一个 Exception 的 对象
  2. 使用 raise 关键字 抛出 异常对象

**需求示例**

- 定义 `input_password` 函数，提示用户输入密码
- 如果用户输入长度 < 8，抛出异常
- 如果用户输入长度 >=8，返回输入的密码

```python
def input_password():

    # 1. 提示用户输入密码
    pwd = input("请输入密码：")

    # 2. 判断密码长度，如果长度 >= 8，返回用户输入的密码
    if len(pwd) >= 8:
        return pwd

    # 3. 密码长度不够，需要抛出异常
    # 1> 创建异常对象 - 使用异常的错误信息字符串作为参数
    ex = Exception("密码长度不够")

    # 2> 抛出异常对象
    raise ex


try:
    user_pwd = input_password()
    print(user_pwd)
except Exception as result:
    print("发现错误：%s" % result
```

## 三 文件操作

### 3.1 操作文件的套路

在 **计算机** 中要操作文件的套路非常固定，一共包含**三个步骤**：

1. 打开文件
2. 读、写文件
   - **读** 将文件内容读入内存
   - **写** 将内存内容写入文件
3. 关闭文件

### 3.2 操作文件的函数/方法

- 在 `Python` 中要操作文件需要记住 1 个函数和 3 个方法

| 序号 | 函数/方法 | 说明                           |
| :--- | :-------- | :----------------------------- |
| 01   | open      | 打开文件，并且返回文件操作对象 |
| 02   | read      | 将文件内容读取到内存           |
| 03   | write     | 将指定内容写入文件             |
| 04   | close     | 关闭文件                       |

- `open` 函数负责打开文件，并且返回文件对象
- `read`/`write`/`close` 三个方法都需要通过 **文件对象** 来调用

### 3.3 read 方法 —— 读取文件

- `open` 函数的第一个参数是要打开的文件名（文件名区分大小写)

  - 如果文件 **存在**，返回 **文件操作对象**
  - 如果文件 **不存在**，会 **抛出异常**

- `read` 方法可以一次性 **读入** 并 **返回** 文件的 **所有内容**

- `close` 方法负责 **关闭文件**

  - 如果 **忘记关闭文件**，**会造成系统资源消耗，而且会影响到后续对文件的访问**

- **注意**：`read` 方法执行后，会把 **文件指针** 移动到 **文件的末尾**

  ```python
  # 1. 打开 - 文件名需要注意大小写
  file = open("README")
  
  # 2. 读取
  text = file.read()
  print(text)
  
  # 3. 关闭
  file.close()
  ```

### 3.4 打开文件的方式

- `open` 函数默认以 **只读方式** 打开文件，并且返回文件对象

语法如下：

```python
f = open("文件名", "访问方式")
```

| 访问方式 | 说明                                                         |
| :------: | :----------------------------------------------------------- |
|    r     | 以**只读**方式打开文件。文件的指针将会放在文件的开头，这是**默认模式**。如果文件不存在，抛出异常 |
|    w     | 以**只写**方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 |
|    a     | 以**追加**方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 |
|    r+    | 以**读写**方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常 |
|    w+    | 以**读写**方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 |
|    a+    | 以**读写**方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 |

> 频繁的移动文件指针，**会影响文件的读写效率**，开发中更多的时候会以 **只读**、**只写** 的方式来操作文件

### 3.5 按行读取文件内容

- `read` 方法默认会把文件的 **所有内容** **一次性读取到内存**
- 如果文件太大，对内存的占用会非常严重

#### `readline` 方法

- `readline` 方法可以一次读取一行内容
- 方法执行后，会把 **文件指针** 移动到下一行，准备再次读取

**读取大文件的正确姿势**

```python
# 打开文件
file = open("README")

while True:
    # 读取一行内容
    text = file.readline()

    # 判断是否读到内容
    if not text:
        break

    # 每读取一行的末尾已经有了一个 `\n`
    print(text, end="")

# 关闭文件
file.close()
```

### 3.6 文件复制

#### 3.6.1 小文件复制

- 打开一个已有文件，读取完整内容，并写入到另外一个文件

```python
# 1. 打开文件
file_read = open("README")
file_write = open("README[复件]", "w")

# 2. 读取并写入文件
text = file_read.read()
file_write.write(text)

# 3. 关闭文件
file_read.close()
file_write.close()
```

#### 3.6.2 大文件复制

- 打开一个已有文件，逐行读取内容，并顺序写入到另外一个文件

```python
# 1. 打开文件
file_read = open("README")
file_write = open("README[复件]", "w")

# 2. 读取并写入文件
while True:
    # 每次读取一行
    text = file_read.readline()

    # 判断是否读取到内容
    if not text:
        break

    file_write.write(text)

# 3. 关闭文件
file_read.close()
file_write.close()
```

###  3.7 文件/目录的常用管理操作

- 在 **终端** / **文件浏览器**、 中可以执行常规的 **文件** / **目录** 管理操作，例如：
  - 创建、重命名、删除、改变路径、查看目录内容、……
- 在 `Python` 中，如果希望通过程序实现上述功能，需要导入 `os` 模块

#### 3.7.1 文件操作

| 序号 | 方法名 | 说明       | 示例                              |
| :--- | :----- | :--------- | :-------------------------------- |
| 01   | rename | 重命名文件 | `os.rename(源文件名, 目标文件名)` |
| 02   | remove | 删除文件   | `os.remove(文件名)`               |

#### 3.7.2 目录操作

| 序号 | 方法名     | 说明           | 示例                      |
| :--- | :--------- | :------------- | :------------------------ |
| 01   | listdir    | 目录列表       | `os.listdir(目录名)`      |
| 02   | mkdir      | 创建目录       | `os.mkdir(目录名)`        |
| 03   | rmdir      | 删除目录       | `os.rmdir(目录名)`        |
| 04   | getcwd     | 获取当前目录   | `os.getcwd()`             |
| 05   | chdir      | 修改工作目录   | `os.chdir(目标目录)`      |
| 06   | path.isdir | 判断是否是文件 | `os.path.isdir(文件路径)` |

> 提示：文件或者目录操作都支持 **相对路径** 和 **绝对路径**

### 3.8 `eval` 函数

`eval()` 函数十分强大 —— **将字符串** 当成 **有效的表达式** 来求值 并 **返回计算结果**

```python
# 基本的数学计算
In [1]: eval("1 + 1")
Out[1]: 2

# 字符串重复
In [2]: eval("'*' * 10")
Out[2]: '**********'

# 将字符串转换成列表
In [3]: type(eval("[1, 2, 3, 4, 5]"))
Out[3]: list

# 将字符串转换成字典
In [4]: type(eval("{'name': 'xiaoming', 'age': 18}"))
Out[4]: dict
```

> *在开发时千万不要使用* `eval` *直接转换* `input` *的结果*

## 四 python中的单例

**单例** —— 让 **类** 创建的对象，在系统中 **只有** **唯一的一个实例**

1. 定义一个 **类属性**，初始值是 `None`，用于记录 **单例对象的引用**
2. 重写 `__new__` 方法
3. 如果 **类属性** `is None`，调用父类方法分配空间，并在类属性中记录结果
4. 返回 **类属性** 中记录的 **对象引用**

```python
class MusicPlayer(object):

    # 定义类属性记录单例对象引用
    instance = None

    def __new__(cls, *args, **kwargs):

        # 1. 判断类属性是否已经被赋值
        if cls.instance is None:
            cls.instance = super().__new__(cls)

        # 2. 返回类属性的单例引用
        return cls.instance
```

只执行一次初始化工作

- 在每次使用 `类名()` 创建对象时，`Python` 的解释器都会自动调用两个方法：
  - `__new__` 分配空间
  - `__init__` 对象初始化
- 在上面内容中对 `__new__` 方法改造之后，每次都会得到 **第一次被创建对象的引用**
- 但是：**初始化方法还会被再次调用**

**需求**

- 让 **初始化动作** 只被 **执行一次**

**解决办法**

1. 定义一个类属性 `init_flag` 标记是否 **执行过初始化动作**，初始值为 `False`
2. 在 `__init__` 方法中，判断 `init_flag`，如果为 `False` 就执行初始化动作
3. 然后将 `init_flag` 设置为 `True`
4. 这样，再次 **自动** 调用 `__init__` 方法时，**初始化动作就不会被再次执行** 了

```python
class MusicPlayer(object):

    # 记录第一个被创建对象的引用
    instance = None
    # 记录是否执行过初始化动作
    init_flag = False

    def __new__(cls, *args, **kwargs):

        # 1. 判断类属性是否是空对象
        if cls.instance is None:
            # 2. 调用父类的方法，为第一个对象分配空间
            cls.instance = super().__new__(cls)

        # 3. 返回类属性保存的对象引用
        return cls.instance

    def __init__(self):

        if not MusicPlayer.init_flag:
            print("初始化音乐播放器")

            MusicPlayer.init_flag = True


# 创建多个对象
player1 = MusicPlayer()
print(player1)

player2 = MusicPlayer()
print(player2)

```

